var y = &ExArg{}
self.hoge = 1
self.ea.range_ = 1
xxx.x = 1
var z = self.ea.range_
var xs = viml_range(10)
Node()
var type_ = 1
var t = type_
var at = type_
var lhs = &lhs{}
var lhs = hoge()
for _, x := range builtin_commands {
}
for _, x := range neovim_removed_commands {
}
for _, x := range neovim_additional_commands {
}
func (self *LvalueParser) pos1() {
	var pos = self.reader.tell()
}

func (self *LvalueParser) pos2() {
	var pos = self.reader.tell()
}

self.ea.forceit = true
self.ea.forceit = false
self.ea.usefilter = true
self.ea.usefilter = false
node.attr.range_ = true
node.attr.abort = true
node.attr.dict = true
// skip
// end skip
// do not skip
node.list = self.parse_lvaluelist()
node.depth = hoge
node.rlist = []*VimNode{nil, nil}
node.rlist = []*VimNode{right, nil}
node.rlist = F()
// end do not skip
var p = NewVimLParser()
var et = NewExprTokenizer(r)
var ep = NewExprParser(r)
var lp = NewLvalueParser(r)
var r = NewStringReader(lines)
var nl = nil
var list []*VimNode
var curly_parts []*VimNode
var cmd *Cmd = nil
cmd = &Cmd{name: name, flags: "USERCMD", parser: "parse_cmd_usercmd"}
// type assertion
var s = left.value.(string)
var vn = isvarname(node.value.(string))
func cache() {
	self.reader.seek_set(x[0].(int))
	return x[1].(*ExprToken)
}

F(self.compile(node.left).(string))
F(self.compile(node.rest).(string))
func F() {
	return node.value.(string)
}

// end type assertion
xs = append(xs, x)
node.value = append(node.value.([]interface{}), []interface{}{key, val})
if cnode.pattern != "" {
}
if node.depth != 0 {
}
var rlist = func() []string {;var ss []string;for _, vval := range node.rlist {;ss = append(ss, self.compile(vval).(string));};return ss;}()
F(func() string { if node.rlist[0] == nil {return "nil"} else {return self.compile(node.rlist[0]).(string)} }())
F(func() string { if node.rlist[1] == nil {return "nil"} else {return self.compile(node.rlist[1]).(string)} }())
